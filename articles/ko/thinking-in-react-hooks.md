---
title: "React Hooks로 사고하기: 현대 상태 관리의 멘탈 모델"
date: 2023년 10월 24일
dateTime: 2023-10-24
readTime: 읽는 시간 8분
excerpt: 프레임워크와 싸우지 않기 위한 멘탈 모델을 정리합니다. 의존성 배열의 '왜'를 이해하고 클로저 함정을 피하는 방법을 살펴봅니다.
categories:
  - 엔지니어링
  - 리액트
commentCount: 12
---

## 소개

React Hooks는 모든 것을 바꿨습니다. 단순한 새로운 API가 아니라 **멘탈 모델**의
전환이었죠. 클래스 컴포넌트에서 함수 컴포넌트와 훅으로 옮길 때 우리는
라이프사이클을 떠올리기보다 *동기화*를 먼저 생각해야 합니다.

## 의존성 배열의 오해

훅을 처음 쓰는 개발자가 가장 많이 실수하는 지점은 `useEffect` 의존성 배열입니다.
우리는 종종 이를 트리거처럼 생각합니다: "X가 바뀌면 이 코드를 실행해." 물론
실무적으로는 맞지만, 이 관점은 오래된 클로저 같은 버그를 만들어냅니다.

```js
useEffect(() => {
  const interval = setInterval(() => {
    // 이 count는 오래된 값일 수 있습니다!
    setCount(count + 1);
  }, 1000);
  return () => clearInterval(interval);
}, []); // 빈 배열이면 한 번만 실행됩니다
```

대신 훅을 "컴포넌트 상태를 외부 세계와 동기화하는 방법"으로 바라보세요.
DOM이든 구독이든, 데이터 요청이든, 훅은 UI가 항상 최신 상태를 반영하도록
도와줍니다.

## 습관을 깨기

전환에는 시간이 걸립니다. `useRef`로 인스턴스 변수를 흉내 내거나 `useMemo`를
과하게 쓰게 될 거예요. 핵심은 React의 선언적 특성을 믿는 것입니다.

> "가장 중요한 점은 훅이 함수라는 사실입니다. 다만 기억을 가진 함수라는 점이죠."

## 마무리

React 여정을 이어가면서 커스텀 훅을 계속 실험해 보세요. 로직 재사용에 가장
강력한 도구이며, 컴포넌트를 깔끔하고 집중된 상태로 유지하게 해줍니다.
